{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDocs Output as Input Plugin","text":"<p>Welcome to the MkDocs Output as Input Plugin documentation! This plugin enables advanced documentation workflows by capturing rendered HTML output from MkDocs and creating \"cousin\" Markdown files that combine original YAML frontmatter with extracted HTML content.</p>"},{"location":"#what-is-output-as-input","title":"What is Output as Input?","text":"<p>The Output as Input plugin bridges the gap between MkDocs and other static site generators by:</p> <ul> <li>\ud83d\udcc4 Capturing rendered HTML from your MkDocs build</li> <li>\ud83d\udd04 Preserving YAML frontmatter from source Markdown files  </li> <li>\ud83d\udcc1 Creating cousin files in a staging directory for further processing</li> <li>\ud83d\udee0\ufe0f Enabling post-processing workflows with other tools</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible HTML extraction - Target specific HTML elements (main, article, div, etc.)</li> <li>Frontmatter preservation - Maintains all YAML metadata from source files</li> <li>Configurable output - Customize staging directory and wrapper tags</li> <li>Error resilience - Graceful handling of parsing errors and edge cases</li> <li>Debug support - Verbose logging for troubleshooting</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install the plugin:</p> <pre><code>pip install mkdocs-output-as-input\n</code></pre> <p>Add to your <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - output-as-input:\n      stage_dir: stage\n      html_element: main\n      target_tag: article\n</code></pre> <p>Build your documentation:</p> <pre><code>mkdocs build\n</code></pre> <p>Find your cousin files in the <code>stage/</code> directory!</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>Configuration - All plugin options explained</li> <li>Examples - Real-world use cases and workflows</li> <li>API Reference - Technical documentation</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Issues</li> <li>Discussions</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This page provides detailed technical documentation for the MkDocs Output as Input plugin.</p>"},{"location":"api/#plugin-class","title":"Plugin Class","text":""},{"location":"api/#mkdocs_output_as_input.plugin.OutputAsInputPlugin","title":"<code>mkdocs_output_as_input.plugin.OutputAsInputPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>MkDocs plugin that captures HTML output and creates cousin Markdown files.</p> <p>This plugin: 1. Lets the entire MkDocs build process run normally 2. Tracks all source Markdown files and their YAML frontmatter 3. After the build, creates a \"stage\" directory that replicates the source structure 4. For each source Markdown file, creates a cousin file with original frontmatter    and extracted HTML</p> Source code in <code>src/mkdocs_output_as_input/plugin.py</code> <pre><code>class OutputAsInputPlugin(BasePlugin):  # type: ignore[type-arg,no-untyped-call]\n    \"\"\"MkDocs plugin that captures HTML output and creates cousin Markdown files.\n\n    This plugin:\n    1. Lets the entire MkDocs build process run normally\n    2. Tracks all source Markdown files and their YAML frontmatter\n    3. After the build, creates a \"stage\" directory that replicates the source structure\n    4. For each source Markdown file, creates a cousin file with original frontmatter\n       and extracted HTML\n    \"\"\"\n\n    config_scheme = (\n        (\"stage_dir\", config_options.Type(str, default=\"stage\")),\n        (\"html_element\", config_options.Type((str, list), default=\"main\")),\n        (\"target_tag\", config_options.Type(str, default=\"article\")),\n        (\"include_frontmatter\", config_options.Type(bool, default=True)),\n        (\"preserve_links\", config_options.Type(bool, default=False)),\n        (\"minify\", config_options.Type(bool, default=False)),\n        (\"prettify\", config_options.Type(bool, default=False)),\n        (\"verbose\", config_options.Type(bool, default=False)),\n    )\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the plugin.\"\"\"\n        super().__init__()\n        self.source_files: dict[str, FileInfo] = {}\n        self.site_dir: Path | None = None\n        self.docs_dir: Path | None = None\n\n    def on_config(self, config: ConfigDict) -&gt; ConfigDict:  # type: ignore[override]\n        \"\"\"Store site and docs directories and validate configuration.\n\n        Args:\n            config: MkDocs configuration dictionary\n\n        Returns:\n            The unmodified configuration dictionary\n\n        Raises:\n            ValueError: If mutually exclusive options are enabled\n        \"\"\"\n        self.site_dir = Path(config[\"site_dir\"])\n        self.docs_dir = Path(config[\"docs_dir\"])\n\n        # Validate mutually exclusive options\n        if self.config[\"minify\"] and self.config[\"prettify\"]:\n            raise ValueError(\"Cannot use both 'minify' and 'prettify' options\")\n\n        if self.config[\"verbose\"]:\n            logger.info(\"Plugin initialized\", site_dir=self.site_dir, docs_dir=self.docs_dir)\n            logger.debug(\"Configuration\", config=self.config)\n\n        return config\n\n    def on_page_read_source(self, page: Page, config: ConfigDict) -&gt; str | None:  # type: ignore[override]  # noqa: ARG002\n        \"\"\"Capture source Markdown content and frontmatter.\n\n        Args:\n            page: MkDocs page object\n            config: MkDocs configuration dictionary\n\n        Returns:\n            None to let MkDocs continue with original content\n        \"\"\"\n        src_path = page.file.src_path\n        start_time = time.time()\n\n        # Read the full source content\n        try:\n            with open(page.file.abs_src_path, encoding=\"utf-8\") as f:  # type: ignore[arg-type]\n                content = f.read()\n        except Exception as e:\n            logger.error(\"Failed to read source file\", path=src_path, error=str(e))\n            return None\n\n        # Extract frontmatter if present\n        frontmatter: FrontmatterDict = {}\n        if content.startswith(\"---\\n\"):\n            try:\n                end_idx = content.find(\"\\n---\\n\", 4)\n                if end_idx &gt; 0:\n                    fm_text = content[4:end_idx]\n                    frontmatter = yaml.safe_load(fm_text) or {}\n            except yaml.YAMLError as e:\n                logger.warning(\"Failed to parse frontmatter\", path=src_path, error=str(e))\n\n        self.source_files[src_path] = {\n            \"frontmatter\": frontmatter,\n            \"abs_src_path\": page.file.abs_src_path,\n        }\n\n        if self.config[\"verbose\"]:\n            elapsed = time.time() - start_time\n            logger.debug(\n                \"Captured source file\",\n                path=src_path,\n                frontmatter_keys=list(frontmatter.keys()),\n                elapsed_ms=f\"{elapsed * 1000:.2f}\"\n            )\n\n        return None  # Let MkDocs continue with original content\n\n    def on_post_build(self, config: ConfigDict) -&gt; None:  # type: ignore[override]  # noqa: ARG002\n        \"\"\"After build, process all HTML files and create cousin Markdowns.\n\n        Args:\n            config: MkDocs configuration dictionary\n        \"\"\"\n        if self.docs_dir is None:\n            logger.error(\"docs_dir not set, cannot process files\")\n            return\n\n        start_time = time.time()\n        stage_dir = self.docs_dir.parent / self.config[\"stage_dir\"]\n\n        # Create stage directory\n        stage_dir.mkdir(exist_ok=True)\n        logger.info(\"Creating stage directory\", path=stage_dir)\n\n        # Process each tracked source file\n        processed = 0\n        failed = 0\n\n        with logger.contextualize(stage_dir=str(stage_dir)):\n            for src_path, file_info in self.source_files.items():\n                try:\n                    self._process_file(src_path, file_info, stage_dir)\n                    processed += 1\n                except Exception as e:\n                    failed += 1\n                    logger.error(\n                        \"Failed to process file\",\n                        path=src_path,\n                        error=str(e),\n                        exc_info=self.config[\"verbose\"]\n                    )\n\n        elapsed = time.time() - start_time\n        logger.info(\n            \"Post-build processing complete\",\n            processed=processed,\n            failed=failed,\n            total=len(self.source_files),\n            elapsed_s=f\"{elapsed:.2f}\"\n        )\n\n    def _process_file(self, src_path: str, file_info: FileInfo, stage_dir: Path) -&gt; None:\n        \"\"\"Process a single file: extract HTML and create cousin Markdown.\n\n        Args:\n            src_path: Path to the source Markdown file\n            file_info: Dictionary containing file metadata and frontmatter\n            stage_dir: Directory where cousin files will be created\n        \"\"\"\n        if self.site_dir is None:\n            logger.error(\"site_dir not set\")\n            return\n\n        # Determine HTML output path\n        # Special case: README.md often becomes index.html at root\n        if src_path.lower() == \"readme.md\":\n            html_path = \"index.html\"\n            full_html_path = self.site_dir / html_path\n        else:\n            html_path = src_path.replace(\".md\", \"/index.html\")\n            full_html_path = self.site_dir / html_path\n\n        if not full_html_path.exists():\n            # Try without the index.html suffix\n            html_path = src_path.replace(\".md\", \".html\")\n            full_html_path = self.site_dir / html_path\n\n        if not full_html_path.exists():\n            logger.warning(\n                \"No HTML output found\",\n                source=src_path,\n                expected_path=str(full_html_path)\n            )\n            return\n\n        # Read and parse HTML\n        try:\n            with open(full_html_path, encoding=\"utf-8\") as f:\n                html_content = f.read()\n        except Exception as e:\n            logger.error(\"Failed to read HTML file\", path=full_html_path, error=str(e))\n            return\n\n        soup = BeautifulSoup(html_content, \"html.parser\")\n\n        # Extract target element(s)\n        html_elements = self.config[\"html_element\"]\n        if isinstance(html_elements, str):\n            html_elements = [html_elements]\n\n        extracted_elements: list[Any] = []\n        for selector in html_elements:\n            # Try CSS selector first\n            elements = soup.select(selector)\n            if elements:\n                extracted_elements.extend(elements)\n            else:\n                # Fall back to tag name\n                element = soup.find(selector)\n                if element:\n                    extracted_elements.append(element)\n\n        if not extracted_elements:\n            logger.warning(\n                \"No matching elements found\",\n                selectors=self.config['html_element'],\n                html_file=str(full_html_path)\n            )\n            return\n\n        # If multiple elements, wrap them in a container\n        if len(extracted_elements) &gt; 1:\n            container = soup.new_tag(self.config[\"target_tag\"])\n            for elem in extracted_elements:\n                container.append(elem.extract())\n            target_element = container\n        else:\n            target_element = extracted_elements[0]  # type: ignore[assignment]\n            # Transform to target tag if different and single selector was a tag name\n            if (isinstance(self.config[\"html_element\"], str) and \n                self.config[\"target_tag\"] != self.config[\"html_element\"]):\n                target_element.name = self.config[\"target_tag\"]\n\n        # Handle link preservation if requested\n        if self.config[\"preserve_links\"]:\n            # Convert absolute links back to relative\n            for link in target_element.find_all([\"a\", \"img\", \"link\", \"script\"]):\n                for attr in [\"href\", \"src\"]:\n                    if link.has_attr(attr):\n                        url = link[attr]\n                        # Simple heuristic: if it starts with /, it's likely a root-relative link\n                        # In a real implementation, this would be more sophisticated\n                        if url.startswith(\"/\") and not url.startswith(\"//\"):\n                            link[attr] = f\".{url}\"\n\n        # Create cousin file path\n        cousin_path = stage_dir / src_path\n        cousin_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write cousin file\n        try:\n            with open(cousin_path, \"w\", encoding=\"utf-8\") as f:\n                # Write frontmatter if present and configured to include it\n                if self.config[\"include_frontmatter\"] and file_info[\"frontmatter\"]:\n                    f.write(\"---\\n\")\n                    f.write(yaml.safe_dump(file_info[\"frontmatter\"], default_flow_style=False))\n                    f.write(\"---\\n\\n\")\n\n                # Write extracted HTML with formatting options\n                if self.config[\"minify\"]:\n                    # Remove extra whitespace between tags\n                    html_output = str(target_element)\n                    # Remove newlines and compress multiple spaces\n                    html_output = html_output.replace(\"\\n\", \"\")\n                    html_output = re.sub(r'\\s+', ' ', html_output)\n                    # Remove spaces between tags\n                    html_output = re.sub(r'&gt;\\s+&lt;', '&gt;&lt;', html_output)\n                elif self.config[\"prettify\"]:\n                    html_output = target_element.prettify()\n                else:\n                    html_output = str(target_element)\n\n                f.write(html_output)\n                f.write(\"\\n\")\n\n            if self.config[\"verbose\"]:\n                logger.debug(\"Created cousin file\", path=cousin_path, size=cousin_path.stat().st_size)\n\n        except Exception as e:\n            logger.error(\"Failed to write cousin file\", path=cousin_path, error=str(e))\n</code></pre>"},{"location":"api/#mkdocs_output_as_input.plugin.OutputAsInputPlugin.config_scheme","title":"<code>config_scheme = (('stage_dir', config_options.Type(str, default='stage')), ('html_element', config_options.Type((str, list), default='main')), ('target_tag', config_options.Type(str, default='article')), ('include_frontmatter', config_options.Type(bool, default=True)), ('preserve_links', config_options.Type(bool, default=False)), ('minify', config_options.Type(bool, default=False)), ('prettify', config_options.Type(bool, default=False)), ('verbose', config_options.Type(bool, default=False)))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/#mkdocs_output_as_input.plugin.OutputAsInputPlugin.on_page_read_source","title":"<code>on_page_read_source(page, config)</code>","text":"<p>Capture source Markdown content and frontmatter.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>MkDocs page object</p> required <code>config</code> <code>ConfigDict</code> <p>MkDocs configuration dictionary</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>None to let MkDocs continue with original content</p> Source code in <code>src/mkdocs_output_as_input/plugin.py</code> <pre><code>def on_page_read_source(self, page: Page, config: ConfigDict) -&gt; str | None:  # type: ignore[override]  # noqa: ARG002\n    \"\"\"Capture source Markdown content and frontmatter.\n\n    Args:\n        page: MkDocs page object\n        config: MkDocs configuration dictionary\n\n    Returns:\n        None to let MkDocs continue with original content\n    \"\"\"\n    src_path = page.file.src_path\n    start_time = time.time()\n\n    # Read the full source content\n    try:\n        with open(page.file.abs_src_path, encoding=\"utf-8\") as f:  # type: ignore[arg-type]\n            content = f.read()\n    except Exception as e:\n        logger.error(\"Failed to read source file\", path=src_path, error=str(e))\n        return None\n\n    # Extract frontmatter if present\n    frontmatter: FrontmatterDict = {}\n    if content.startswith(\"---\\n\"):\n        try:\n            end_idx = content.find(\"\\n---\\n\", 4)\n            if end_idx &gt; 0:\n                fm_text = content[4:end_idx]\n                frontmatter = yaml.safe_load(fm_text) or {}\n        except yaml.YAMLError as e:\n            logger.warning(\"Failed to parse frontmatter\", path=src_path, error=str(e))\n\n    self.source_files[src_path] = {\n        \"frontmatter\": frontmatter,\n        \"abs_src_path\": page.file.abs_src_path,\n    }\n\n    if self.config[\"verbose\"]:\n        elapsed = time.time() - start_time\n        logger.debug(\n            \"Captured source file\",\n            path=src_path,\n            frontmatter_keys=list(frontmatter.keys()),\n            elapsed_ms=f\"{elapsed * 1000:.2f}\"\n        )\n\n    return None  # Let MkDocs continue with original content\n</code></pre>"},{"location":"api/#mkdocs_output_as_input.plugin.OutputAsInputPlugin.on_post_build","title":"<code>on_post_build(config)</code>","text":"<p>After build, process all HTML files and create cousin Markdowns.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConfigDict</code> <p>MkDocs configuration dictionary</p> required Source code in <code>src/mkdocs_output_as_input/plugin.py</code> <pre><code>def on_post_build(self, config: ConfigDict) -&gt; None:  # type: ignore[override]  # noqa: ARG002\n    \"\"\"After build, process all HTML files and create cousin Markdowns.\n\n    Args:\n        config: MkDocs configuration dictionary\n    \"\"\"\n    if self.docs_dir is None:\n        logger.error(\"docs_dir not set, cannot process files\")\n        return\n\n    start_time = time.time()\n    stage_dir = self.docs_dir.parent / self.config[\"stage_dir\"]\n\n    # Create stage directory\n    stage_dir.mkdir(exist_ok=True)\n    logger.info(\"Creating stage directory\", path=stage_dir)\n\n    # Process each tracked source file\n    processed = 0\n    failed = 0\n\n    with logger.contextualize(stage_dir=str(stage_dir)):\n        for src_path, file_info in self.source_files.items():\n            try:\n                self._process_file(src_path, file_info, stage_dir)\n                processed += 1\n            except Exception as e:\n                failed += 1\n                logger.error(\n                    \"Failed to process file\",\n                    path=src_path,\n                    error=str(e),\n                    exc_info=self.config[\"verbose\"]\n                )\n\n    elapsed = time.time() - start_time\n    logger.info(\n        \"Post-build processing complete\",\n        processed=processed,\n        failed=failed,\n        total=len(self.source_files),\n        elapsed_s=f\"{elapsed:.2f}\"\n    )\n</code></pre>"},{"location":"api/#configuration-schema","title":"Configuration Schema","text":"<p>The plugin uses MkDocs' configuration validation system:</p> <pre><code>from mkdocs.config import config_options\nfrom mkdocs.plugins import BasePlugin\n\nclass OutputAsInputPlugin(BasePlugin):\n    config_scheme = (\n        ('stage_dir', config_options.Type(str, default='stage')),\n        ('html_element', config_options.Type(str, default='main')),\n        ('target_tag', config_options.Type(str, default='article')),\n        ('verbose', config_options.Type(bool, default=False)),\n    )\n</code></pre>"},{"location":"api/#event-hooks","title":"Event Hooks","text":""},{"location":"api/#on_page_read_source","title":"<code>on_page_read_source</code>","text":"<p>Called when MkDocs reads a source file. The plugin uses this to capture frontmatter.</p> <p>Parameters: - <code>page</code> - The MkDocs Page object - <code>config</code> - The MkDocs configuration</p> <p>Returns: - The original page content (unmodified)</p> <p>Behavior: 1. Extracts YAML frontmatter from the source file 2. Stores source path and frontmatter for later use 3. Handles parsing errors gracefully</p>"},{"location":"api/#on_post_build","title":"<code>on_post_build</code>","text":"<p>Called after MkDocs completes the build. This is where cousin files are created.</p> <p>Parameters: - <code>config</code> - The MkDocs configuration</p> <p>Behavior: 1. Creates the stage directory if needed 2. Processes each HTML file in the site directory 3. Extracts content using BeautifulSoup 4. Creates cousin Markdown files with frontmatter + HTML</p>"},{"location":"api/#internal-methods","title":"Internal Methods","text":""},{"location":"api/#_extract_frontmattercontent-str-tupledict-str","title":"<code>_extract_frontmatter(content: str) -&gt; tuple[dict, str]</code>","text":"<p>Extracts YAML frontmatter from Markdown content.</p> <p>Parameters: - <code>content</code> - Raw Markdown file content</p> <p>Returns: - Tuple of (frontmatter_dict, remaining_content)</p> <p>Example: <pre><code>frontmatter, content = plugin._extract_frontmatter(\"\"\"---\ntitle: My Page\ntags: [python, mkdocs]\n---\n\n# Content here\n\"\"\")\n# frontmatter = {'title': 'My Page', 'tags': ['python', 'mkdocs']}\n# content = \"\\n# Content here\\n\"\n</code></pre></p>"},{"location":"api/#_create_cousin_filesite_dir-str-rel_path-str-frontmatter-dict-html_content-str","title":"<code>_create_cousin_file(site_dir: str, rel_path: str, frontmatter: dict, html_content: str)</code>","text":"<p>Creates a cousin Markdown file with frontmatter and HTML content.</p> <p>Parameters: - <code>site_dir</code> - The MkDocs site output directory - <code>rel_path</code> - Relative path of the source file - <code>frontmatter</code> - Dictionary of frontmatter data - <code>html_content</code> - Extracted HTML content</p>"},{"location":"api/#data-storage","title":"Data Storage","text":"<p>The plugin stores page information during build:</p> <pre><code>self.page_sources: Dict[str, Dict[str, Any]] = {\n    'index.md': {\n        'source_path': 'docs/index.md',\n        'frontmatter': {'title': 'Home', 'date': '2024-01-20'}\n    },\n    'guide.md': {\n        'source_path': 'docs/guide.md', \n        'frontmatter': {'title': 'User Guide'}\n    }\n}\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>The plugin handles various error cases:</p>"},{"location":"api/#missing-html-element","title":"Missing HTML Element","text":"<pre><code>if not element:\n    logger.warning(f\"Element '{self.config['html_element']}' not found\")\n    return\n</code></pre>"},{"location":"api/#invalid-frontmatter","title":"Invalid Frontmatter","text":"<pre><code>try:\n    frontmatter = yaml.safe_load(fm_text) or {}\nexcept yaml.YAMLError as e:\n    logger.error(f\"Invalid YAML frontmatter: {e}\")\n    frontmatter = {}\n</code></pre>"},{"location":"api/#file-io-errors","title":"File I/O Errors","text":"<pre><code>try:\n    with open(output_path, 'w', encoding='utf-8') as f:\n        f.write(content)\nexcept IOError as e:\n    logger.error(f\"Failed to write file: {e}\")\n</code></pre>"},{"location":"api/#usage-in-python","title":"Usage in Python","text":""},{"location":"api/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>from mkdocs_output_as_input import OutputAsInputPlugin\nfrom mkdocs.config import load_config\n\n# Load MkDocs configuration\nconfig = load_config('mkdocs.yml')\n\n# Create plugin instance\nplugin = OutputAsInputPlugin()\nplugin.load_config(\n    options={'stage_dir': 'output', 'verbose': True},\n    config_file_path='mkdocs.yml'\n)\n\n# Use in custom build process\nplugin.on_page_read_source(page, config)\nplugin.on_post_build(config)\n</code></pre>"},{"location":"api/#custom-integration","title":"Custom Integration","text":"<pre><code>import mkdocs.plugins\n\n# Register custom event handler\n@mkdocs.plugins.event_priority(50)\ndef on_post_build(config):\n    # Custom post-processing after Output as Input\n    stage_dir = Path(config['plugins']['output-as-input']['stage_dir'])\n    for md_file in stage_dir.glob('**/*.md'):\n        # Additional processing\n        process_cousin_file(md_file)\n</code></pre>"},{"location":"api/#cli-tool","title":"CLI Tool","text":"<p>The plugin includes a CLI tool for testing:</p> <p>CLI tool for standalone processing of HTML files with output-as-input plugin.</p>"},{"location":"api/#mkdocs_output_as_input.cli.main","title":"<code>main()</code>","text":"<p>Main CLI entry point.</p> Source code in <code>src/mkdocs_output_as_input/cli.py</code> <pre><code>def main() -&gt; int:\n    \"\"\"Main CLI entry point.\"\"\"\n    from mkdocs_output_as_input import __version__\n\n    parser = argparse.ArgumentParser(\n        description=\"Process HTML files with MkDocs Output as Input plugin logic\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  # Process a single file\n  mkdocs-output-as-input process input.html output.md\n\n  # Process with custom element and tag\n  mkdocs-output-as-input process input.html output.md --html-element div --target-tag section\n\n  # Process without frontmatter\n  mkdocs-output-as-input process input.html output.md --no-frontmatter\n\n  # Process with link preservation and prettify\n  mkdocs-output-as-input process input.html output.md --preserve-links --prettify\n        \"\"\",\n    )\n\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=f\"mkdocs-output-as-input {__version__}\",\n        help=\"Show version information and exit\",\n    )\n\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Available commands\")\n\n    # Process command\n    process_parser = subparsers.add_parser(\"process\", help=\"Process HTML file(s)\")\n    process_parser.add_argument(\"input\", type=Path, help=\"Input HTML file\")\n    process_parser.add_argument(\"output\", type=Path, help=\"Output Markdown file\")\n    process_parser.add_argument(\n        \"--html-element\",\n        action=\"append\",\n        help=\"HTML element(s) to extract (can be specified multiple times, default: main)\",\n    )\n    process_parser.add_argument(\n        \"--target-tag\",\n        default=\"article\",\n        help=\"Target tag for output (default: article)\",\n    )\n    process_parser.add_argument(\n        \"--no-frontmatter\",\n        action=\"store_false\",\n        dest=\"include_frontmatter\",\n        help=\"Exclude frontmatter from output\",\n    )\n    process_parser.add_argument(\n        \"--preserve-links\",\n        action=\"store_true\",\n        help=\"Preserve relative links in HTML\",\n    )\n    process_parser.add_argument(\n        \"--minify\",\n        action=\"store_true\",\n        help=\"Minify HTML output\",\n    )\n    process_parser.add_argument(\n        \"--prettify\",\n        action=\"store_true\",\n        help=\"Prettify HTML output\",\n    )\n    process_parser.add_argument(\n        \"-v\", \"--verbose\",\n        action=\"store_true\",\n        help=\"Enable verbose logging\",\n    )\n\n    args = parser.parse_args()\n\n    if not args.command:\n        parser.print_help()\n        return 1\n\n    # Set up logging\n    setup_logging(args.verbose)\n\n    try:\n        if args.command == \"process\":\n            # Validate mutually exclusive options\n            if args.minify and args.prettify:\n                logger.error(\"Cannot use both --minify and --prettify\")\n                return 1\n\n            # Default to \"main\" if no elements specified\n            html_element = args.html_element if args.html_element else \"main\"\n\n            process_file(\n                args.input,\n                args.output,\n                html_element=html_element,\n                target_tag=args.target_tag,\n                include_frontmatter=args.include_frontmatter,\n                preserve_links=args.preserve_links,\n                minify=args.minify,\n                prettify=args.prettify,\n            )\n            return 0\n    except Exception as e:\n        logger.error(\"Command failed\", error=str(e))\n        return 1\n\n    return 0\n</code></pre>"},{"location":"api/#mkdocs_output_as_input.cli.process_file","title":"<code>process_file(input_path, output_path, html_element='main', target_tag='article', include_frontmatter=True, preserve_links=False, minify=False, prettify=False)</code>","text":"<p>Process a single file.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Path</code> <p>Path to input HTML file</p> required <code>output_path</code> <code>Path</code> <p>Path to output Markdown file</p> required <code>html_element</code> <code>ElementList</code> <p>CSS selector for element to extract</p> <code>'main'</code> <code>target_tag</code> <code>str</code> <p>Tag to replace the extracted element with</p> <code>'article'</code> <code>include_frontmatter</code> <code>bool</code> <p>Whether to include frontmatter in output</p> <code>True</code> <code>preserve_links</code> <code>bool</code> <p>Whether to preserve relative links</p> <code>False</code> <code>minify</code> <code>bool</code> <p>Whether to minify the output</p> <code>False</code> <code>prettify</code> <code>bool</code> <p>Whether to prettify the output</p> <code>False</code> Source code in <code>src/mkdocs_output_as_input/cli.py</code> <pre><code>def process_file(\n    input_path: Path,\n    output_path: Path,\n    html_element: ElementList = \"main\",\n    target_tag: str = \"article\",\n    include_frontmatter: bool = True,\n    preserve_links: bool = False,\n    minify: bool = False,\n    prettify: bool = False,\n) -&gt; None:\n    \"\"\"Process a single file.\n\n    Args:\n        input_path: Path to input HTML file\n        output_path: Path to output Markdown file\n        html_element: CSS selector for element to extract\n        target_tag: Tag to replace the extracted element with\n        include_frontmatter: Whether to include frontmatter in output\n        preserve_links: Whether to preserve relative links\n        minify: Whether to minify the output\n        prettify: Whether to prettify the output\n    \"\"\"\n    logger.info(\"Processing file\", input=str(input_path), output=str(output_path))\n\n    # Read input file\n    try:\n        content = input_path.read_text(encoding=\"utf-8\")\n    except Exception as e:\n        logger.error(\"Failed to read input file\", path=input_path, error=str(e))\n        raise\n\n    # Check if there's a corresponding markdown file for frontmatter\n    frontmatter: FrontmatterDict = {}\n    if include_frontmatter:\n        md_path = input_path.with_suffix(\".md\")\n        if md_path.exists():\n            try:\n                md_content = md_path.read_text(encoding=\"utf-8\")\n                frontmatter, _ = extract_frontmatter(md_content)\n                logger.debug(\"Extracted frontmatter\", path=md_path, keys=list(frontmatter.keys()))\n            except Exception as e:\n                logger.warning(\"Failed to read markdown file\", path=md_path, error=str(e))\n\n    # Process HTML\n    processed_html = process_html(\n        content,\n        html_element=html_element,\n        target_tag=target_tag,\n        preserve_links=preserve_links,\n        minify=minify,\n        prettify=prettify,\n    )\n\n    if processed_html is None:\n        raise ValueError(f\"Failed to process HTML from {input_path}\")\n\n    # Create output directory if needed\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write output\n    try:\n        with output_path.open(\"w\", encoding=\"utf-8\") as f:\n            # Write frontmatter if present and configured\n            if include_frontmatter and frontmatter:\n                f.write(\"---\\n\")\n                f.write(yaml.safe_dump(frontmatter, default_flow_style=False))\n                f.write(\"---\\n\\n\")\n\n            # Write processed HTML\n            f.write(processed_html)\n            f.write(\"\\n\")\n\n        logger.info(\"Successfully wrote output file\", path=output_path, size=output_path.stat().st_size)\n    except Exception as e:\n        logger.error(\"Failed to write output file\", path=output_path, error=str(e))\n        raise\n</code></pre>"},{"location":"api/#cli-usage","title":"CLI Usage","text":"<pre><code># Process a single file\noutput-as-input process file.html --element main --output output.md\n\n# Process directory\noutput-as-input process site/ --element article --stage-dir stage/\n\n# With verbose output\noutput-as-input process site/ --verbose\n</code></pre>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>The plugin uses type hints for better IDE support:</p> <pre><code>from typing import Dict, Any, Optional, Tuple\nfrom mkdocs.structure.pages import Page\nfrom mkdocs.config.defaults import MkDocsConfig\n\ndef on_page_read_source(\n    self, \n    page: Page, \n    config: MkDocsConfig\n) -&gt; Optional[str]: ...\n\ndef _extract_frontmatter(\n    self, \n    content: str\n) -&gt; Tuple[Dict[str, Any], str]: ...\n</code></pre>"},{"location":"api/#logging","title":"Logging","text":"<p>The plugin uses the <code>loguru</code> logger:</p> <pre><code>from loguru import logger\n\n# Info level (always shown)\nlogger.info(f\"Processing page: {page.file.src_path}\")\n\n# Debug level (shown with verbose=true)\nlogger.debug(f\"Extracted frontmatter: {frontmatter}\")\n\n# Warning level\nlogger.warning(f\"Element not found: {element}\")\n\n# Error level  \nlogger.error(f\"Failed to parse HTML: {e}\")\n</code></pre>"},{"location":"api/#testing","title":"Testing","text":"<p>Test helpers for plugin development:</p> <pre><code>import pytest\nfrom mkdocs_output_as_input import OutputAsInputPlugin\n\n@pytest.fixture\ndef plugin():\n    plugin = OutputAsInputPlugin()\n    plugin.load_config(options={}, config_file_path='')\n    return plugin\n\ndef test_frontmatter_extraction(plugin):\n    content = \"---\\ntitle: Test\\n---\\n# Content\"\n    fm, body = plugin._extract_frontmatter(content)\n    assert fm == {'title': 'Test'}\n    assert '# Content' in body\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>The MkDocs Output as Input plugin provides several configuration options to customize its behavior. All options are set in your <code>mkdocs.yml</code> file.</p>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"configuration/#stage_dir","title":"<code>stage_dir</code>","text":"<p>Type: <code>str</code> Default: <code>\"stage\"</code></p> <p>The directory where cousin files will be created. Can be relative to the MkDocs project root or an absolute path.</p> <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"output/markdown\"\n</code></pre> <p>Tip</p> <p>Use an absolute path to place files outside your project: <pre><code>stage_dir: \"/var/www/content\"\n</code></pre></p>"},{"location":"configuration/#html_element","title":"<code>html_element</code>","text":"<p>Type: <code>str</code> Default: <code>\"main\"</code></p> <p>The HTML element or CSS selector to extract from rendered pages. </p> <p>Common values: - <code>\"main\"</code> - Main content area (default) - <code>\"article\"</code> - Article content - <code>\"#content\"</code> - Element with id=\"content\" - <code>\".documentation\"</code> - Elements with class=\"documentation\" - <code>\"div.content\"</code> - Div elements with class=\"content\"</p> <pre><code>plugins:\n  - output-as-input:\n      html_element: \"article\"\n</code></pre> <p>Warning</p> <p>If the specified element is not found, the plugin will log a warning and skip that page.</p>"},{"location":"configuration/#target_tag","title":"<code>target_tag</code>","text":"<p>Type: <code>str</code> Default: <code>\"article\"</code></p> <p>The HTML tag used to wrap the extracted content in cousin files.</p> <pre><code>plugins:\n  - output-as-input:\n      target_tag: \"section\"\n</code></pre> <p>This would produce: <pre><code>---\ntitle: Page Title\n---\n\n&lt;section&gt;\n&lt;!-- extracted content --&gt;\n&lt;/section&gt;\n</code></pre></p>"},{"location":"configuration/#verbose","title":"<code>verbose</code>","text":"<p>Type: <code>bool</code> Default: <code>false</code></p> <p>Enable detailed debug logging to help troubleshoot issues.</p> <pre><code>plugins:\n  - output-as-input:\n      verbose: true\n</code></pre> <p>When enabled, the plugin logs: - Each file being processed - Extraction results - Any errors or warnings - File creation details</p>"},{"location":"configuration/#complete-example","title":"Complete Example","text":"<p>Here's a complete configuration example showing all options:</p> <pre><code>site_name: My Documentation\nsite_url: https://example.com/docs/\n\ntheme:\n  name: material\n\nplugins:\n  - search\n  - output-as-input:\n      stage_dir: \"staged-content\"\n      html_element: \"article.md-content\"\n      target_tag: \"div\"\n      verbose: true\n\nnav:\n  - Home: index.md\n  - Guide: guide.md\n  - API: api.md\n</code></pre>"},{"location":"configuration/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"configuration/#for-static-site-generators","title":"For Static Site Generators","text":"<p>When using with Hugo: <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"../hugo/content/docs\"\n      html_element: \"main\"\n      target_tag: \"div\"  # Hugo prefers div\n</code></pre></p> <p>When using with Jekyll: <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"../jekyll/_posts\"\n      html_element: \"article\"\n      target_tag: \"article\"\n</code></pre></p>"},{"location":"configuration/#for-different-themes","title":"For Different Themes","text":"<p>Material for MkDocs: <pre><code>plugins:\n  - output-as-input:\n      html_element: \"article.md-content__inner\"\n</code></pre></p> <p>ReadTheDocs theme: <pre><code>plugins:\n  - output-as-input:\n      html_element: \"div.rst-content\"\n</code></pre></p> <p>Default MkDocs theme: <pre><code>plugins:\n  - output-as-input:\n      html_element: \"div.col-md-9\"\n</code></pre></p>"},{"location":"configuration/#for-printpdf-generation","title":"For Print/PDF Generation","text":"<pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"print-output\"\n      html_element: \"main\"\n      target_tag: \"div\"\n      # Then use pandoc or similar to convert\n</code></pre>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"<p>You can use environment variables in configuration:</p> <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"${OUTPUT_DIR:-stage}\"\n      verbose: \"${DEBUG:-false}\"\n</code></pre>"},{"location":"configuration/#validation","title":"Validation","text":"<p>The plugin validates configuration on startup:</p> <ul> <li><code>stage_dir</code> must be a valid path</li> <li><code>html_element</code> must be a non-empty string</li> <li><code>target_tag</code> must be a valid HTML tag name</li> <li><code>verbose</code> must be a boolean</li> </ul> <p>Invalid configuration will raise an error during MkDocs build.</p>"},{"location":"configuration/#default-behavior","title":"Default Behavior","text":"<p>With no configuration, the plugin uses these defaults:</p> <pre><code>plugins:\n  - output-as-input\n  # Equivalent to:\n  # - output-as-input:\n  #     stage_dir: \"stage\"\n  #     html_element: \"main\"\n  #     target_tag: \"article\"\n  #     verbose: false\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>This page demonstrates various use cases and workflows for the MkDocs Output as Input plugin.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/#simple-documentation-site","title":"Simple Documentation Site","text":"<p>Basic setup for extracting documentation content:</p> <pre><code># mkdocs.yml\nsite_name: My API Docs\nplugins:\n  - output-as-input:\n      stage_dir: extracted\n      html_element: main\n</code></pre> <p>Input (<code>docs/api.md</code>): <pre><code>---\ntitle: API Reference\nversion: 1.0.0\ncategory: reference\n---\n\n# API Reference\n\n## GET /users\n\nReturns a list of users.\n</code></pre></p> <p>Output (<code>extracted/api.md</code>): <pre><code>---\ntitle: API Reference\nversion: 1.0.0\ncategory: reference\n---\n\n&lt;article&gt;\n&lt;h1&gt;API Reference&lt;/h1&gt;\n&lt;h2&gt;GET /users&lt;/h2&gt;\n&lt;p&gt;Returns a list of users.&lt;/p&gt;\n&lt;/article&gt;\n</code></pre></p>"},{"location":"examples/#preserving-complex-frontmatter","title":"Preserving Complex Frontmatter","text":"<p>The plugin preserves all YAML frontmatter:</p> <pre><code>---\ntitle: Advanced Page\ndate: 2024-01-20\nauthors:\n  - name: Jane Doe\n    email: jane@example.com\n  - name: John Smith\ntags: [tutorial, advanced, python]\nmetadata:\n  difficulty: intermediate\n  duration: 30min\n  requirements:\n    - Python 3.8+\n    - MkDocs 1.4+\n---\n\n# Content here...\n</code></pre> <p>All frontmatter is preserved in the cousin file.</p>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/#hugo-integration","title":"Hugo Integration","text":"<p>Using the plugin to feed content into a Hugo site:</p> <pre><code># mkdocs.yml\nplugins:\n  - output-as-input:\n      stage_dir: \"../hugo-site/content/docs\"\n      html_element: \"article\"\n      target_tag: \"div\"\n</code></pre> <pre><code># Build workflow\nmkdocs build\ncd ../hugo-site\nhugo build\n</code></pre>"},{"location":"examples/#jekyll-blog-posts","title":"Jekyll Blog Posts","text":"<p>Converting documentation to Jekyll blog posts:</p> <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"../jekyll/_posts\"\n      html_element: \"main\"\n</code></pre> <p>With custom frontmatter: <pre><code>---\ntitle: \"New Feature Release\"\ndate: 2024-01-20\nlayout: post\ncategories: [releases, features]\n---\n</code></pre></p>"},{"location":"examples/#docusaurus-integration","title":"Docusaurus Integration","text":"<pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"../docusaurus/docs\"\n      html_element: \".md-content\"\n      target_tag: \"div\"\n</code></pre>"},{"location":"examples/#advanced-workflows","title":"Advanced Workflows","text":""},{"location":"examples/#multi-language-documentation","title":"Multi-Language Documentation","text":"<p>Process documentation for different languages:</p> <pre><code># mkdocs.yml\nplugins:\n  - output-as-input:\n      stage_dir: \"stage/${LANGUAGE}\"\n      html_element: \"main\"\n      verbose: true\n</code></pre> <pre><code># Build for multiple languages\nLANGUAGE=en mkdocs build\nLANGUAGE=es mkdocs build -f mkdocs.es.yml\nLANGUAGE=fr mkdocs build -f mkdocs.fr.yml\n</code></pre>"},{"location":"examples/#api-documentation-pipeline","title":"API Documentation Pipeline","text":"<p>Extract API docs for further processing:</p> <pre><code># post_process.py\nimport os\nimport yaml\nfrom pathlib import Path\n\nstage_dir = Path(\"stage\")\napi_docs = []\n\nfor md_file in stage_dir.glob(\"api/*.md\"):\n    with open(md_file) as f:\n        content = f.read()\n        # Extract frontmatter\n        if content.startswith(\"---\"):\n            _, fm, body = content.split(\"---\", 2)\n            metadata = yaml.safe_load(fm)\n            api_docs.append({\n                \"endpoint\": metadata.get(\"endpoint\"),\n                \"method\": metadata.get(\"method\"),\n                \"content\": body\n            })\n\n# Generate OpenAPI spec, Postman collection, etc.\n</code></pre>"},{"location":"examples/#print-ready-documentation","title":"Print-Ready Documentation","text":"<p>Create print-optimized versions:</p> <pre><code>plugins:\n  - output-as-input:\n      stage_dir: \"print\"\n      html_element: \"article\"\n      target_tag: \"div\"\n</code></pre> <pre><code># Convert to PDF\nmkdocs build\npandoc print/*.md -o documentation.pdf \\\n  --template=mytemplate.tex \\\n  --pdf-engine=xelatex\n</code></pre>"},{"location":"examples/#search-index-generation","title":"Search Index Generation","text":"<p>Build custom search indexes:</p> <pre><code># build_search.py\nimport json\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\n\nsearch_index = []\nstage_dir = Path(\"stage\")\n\nfor md_file in stage_dir.glob(\"**/*.md\"):\n    with open(md_file) as f:\n        content = f.read()\n        # Parse HTML content\n        if \"&lt;article&gt;\" in content:\n            soup = BeautifulSoup(content, 'html.parser')\n            article = soup.find('article')\n            search_index.append({\n                \"path\": str(md_file),\n                \"title\": soup.find('h1').text if soup.find('h1') else \"\",\n                \"content\": article.get_text(),\n                \"url\": f\"/{md_file.relative_to(stage_dir)}\"\n            })\n\nwith open(\"search_index.json\", \"w\") as f:\n    json.dump(search_index, f)\n</code></pre>"},{"location":"examples/#theme-specific-examples","title":"Theme-Specific Examples","text":""},{"location":"examples/#material-for-mkdocs","title":"Material for MkDocs","text":"<pre><code>theme:\n  name: material\n\nplugins:\n  - output-as-input:\n      html_element: \"article.md-content__inner\"\n      stage_dir: \"material-output\"\n</code></pre>"},{"location":"examples/#readthedocs-theme","title":"ReadTheDocs Theme","text":"<pre><code>theme:\n  name: readthedocs\n\nplugins:\n  - output-as-input:\n      html_element: \"div.rst-content\"\n      stage_dir: \"rtd-output\"\n</code></pre>"},{"location":"examples/#custom-theme","title":"Custom Theme","text":"<pre><code>theme:\n  name: custom\n  custom_dir: overrides/\n\nplugins:\n  - output-as-input:\n      html_element: \"#custom-content\"\n      stage_dir: \"custom-output\"\n</code></pre>"},{"location":"examples/#debugging-examples","title":"Debugging Examples","text":""},{"location":"examples/#verbose-logging","title":"Verbose Logging","text":"<p>Enable detailed logging to troubleshoot:</p> <pre><code>plugins:\n  - output-as-input:\n      verbose: true\n      stage_dir: \"debug-output\"\n</code></pre> <p>Output: <pre><code>INFO: OutputAsInput: Processing page: index.md\nDEBUG: OutputAsInput: Found frontmatter: {'title': 'Home', 'date': '2024-01-20'}\nDEBUG: OutputAsInput: Extracted content from &lt;main&gt; element\nINFO: OutputAsInput: Created cousin file: debug-output/index.md\n</code></pre></p>"},{"location":"examples/#testing-selectors","title":"Testing Selectors","text":"<p>Test different HTML selectors:</p> <pre><code># test_selectors.py\nfrom bs4 import BeautifulSoup\n\nwith open(\"site/index.html\") as f:\n    soup = BeautifulSoup(f.read(), 'html.parser')\n\n    selectors = [\"main\", \"article\", \".content\", \"#main-content\"]\n    for selector in selectors:\n        element = soup.select_one(selector)\n        if element:\n            print(f\"\u2713 Found {selector}: {len(element.text)} chars\")\n        else:\n            print(f\"\u2717 Not found: {selector}\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get up and running with the MkDocs Output as Input plugin in minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>MkDocs 1.4.0 or higher</li> <li>Basic familiarity with MkDocs</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi","title":"From PyPI","text":"<p>The easiest way to install the plugin is from PyPI:</p> <pre><code>pip install mkdocs-output-as-input\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":"<p>For development or to get the latest features:</p> <pre><code>git clone https://github.com/vexyart/vexy-mkdocs-output-as-input.git\ncd vexy-mkdocs-output-as-input\npip install -e .\n</code></pre>"},{"location":"getting-started/#basic-configuration","title":"Basic Configuration","text":"<p>Add the plugin to your <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - output-as-input\n</code></pre> <p>This uses the default configuration: - Output directory: <code>stage/</code> - HTML element to extract: <code>&lt;main&gt;</code> - Wrapper tag: <code>&lt;article&gt;</code></p>"},{"location":"getting-started/#your-first-build","title":"Your First Build","text":"<ol> <li>Create a simple MkDocs project:</li> </ol> <pre><code>mkdocs new my-project\ncd my-project\n</code></pre> <ol> <li>Add some frontmatter to <code>docs/index.md</code>:</li> </ol> <pre><code>---\ntitle: Home\ndate: 2024-01-20\ntags: [intro, welcome]\n---\n\n# Welcome to My Docs\n\nThis is a test page.\n</code></pre> <ol> <li>Configure the plugin in <code>mkdocs.yml</code>:</li> </ol> <pre><code>site_name: My Docs\nplugins:\n  - output-as-input:\n      verbose: true\n</code></pre> <ol> <li>Build your site:</li> </ol> <pre><code>mkdocs build\n</code></pre> <ol> <li>Check the output in <code>stage/index.md</code>:</li> </ol> <pre><code>---\ntitle: Home\ndate: 2024-01-20\ntags: [intro, welcome]\n---\n\n&lt;article&gt;\n&lt;h1&gt;Welcome to My Docs&lt;/h1&gt;\n&lt;p&gt;This is a test page.&lt;/p&gt;\n&lt;/article&gt;\n</code></pre>"},{"location":"getting-started/#what-happens-during-build","title":"What Happens During Build?","text":"<ol> <li>Source Reading: The plugin captures each Markdown file and its frontmatter</li> <li>HTML Generation: MkDocs renders your Markdown to HTML as usual</li> <li>HTML Extraction: The plugin extracts the specified HTML element from each page</li> <li>File Creation: Cousin files are created in the stage directory with:</li> <li>Original YAML frontmatter</li> <li>Extracted HTML wrapped in your target tag</li> </ol>"},{"location":"getting-started/#common-use-cases","title":"Common Use Cases","text":""},{"location":"getting-started/#post-processing-with-hugo","title":"Post-Processing with Hugo","text":"<pre><code># mkdocs.yml\nplugins:\n  - output-as-input:\n      stage_dir: ../hugo-site/content\n      target_tag: div\n</code></pre>"},{"location":"getting-started/#creating-print-ready-documents","title":"Creating Print-Ready Documents","text":"<pre><code>plugins:\n  - output-as-input:\n      html_element: article\n      stage_dir: print-ready\n</code></pre>"},{"location":"getting-started/#extracting-for-api-documentation","title":"Extracting for API Documentation","text":"<pre><code>plugins:\n  - output-as-input:\n      html_element: \".api-content\"\n      target_tag: section\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about all Configuration Options</li> <li>See more Examples</li> <li>Read the API Reference for advanced usage</li> </ul>"}]}